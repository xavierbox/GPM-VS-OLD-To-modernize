// -- Schlumberger Private --

#include "gpm_write_vtk_file.h"

namespace Slb { namespace Exploration { namespace Gpm {

void gpm_vtk_output::setup_simple_conversion(const int_extent_2d& ext, float row_height, float column_width)
{
    extent = ext;
    convert_to_world = [row_height, column_width](int i, int j, float* x, float* y)
    {
        *x = j*column_width;
        *y = i*row_height;
    };
}

void gpm_vtk_output::setup_constant_geometry(const std::string& name, float const_val)
{
    const accessor_2d_float_type surf = [const_val](int i, int j) { return const_val; };
    std::vector<accessor_2d_float_type> surf_vec(1, surf);
    geometries = name_accessor_float_type(name, surf_vec);
}

void gpm_vtk_output::setup_model_conversion(const gpm_model_definition& model)
{
    extent = model.model_extent();
    convert_to_world = [&model](int i, int j, float* x, float* y)
    {
        const gpm_model_definition::index_pt ind{ static_cast<float>(i), static_cast<float>(j) };
        const auto world = model.convert_from_index_to_world(ind);
        *x = world.x;
        *y = world.y;
    };
}

void gpm_vtk_output::push_back_float(const std::string& name, const gpm_array_2d_base<float>& data)
{
    accessor_2d_float_type func = [&data](int i, int j) { return data(i, j); };
    float_properties.emplace_back(name,
        std::vector<accessor_2d_float_type>(1, func));
}

void gpm_vtk_output::push_back_float(const std::string& name, const accessor_2d_float_type& data)
{
    float_properties.emplace_back(name,
        std::vector<accessor_2d_float_type>(1, data));
}

void gpm_vtk_output::push_back_vector(const std::string& name, const gpm_array_2d_base<float>& vx,
    const gpm_array_2d_base<float>& vy)
{
    accessor_2d_float_type wave_dir_x = [&vx](int i, int j) { return vx(i, j); };
    accessor_2d_float_type wave_dir_y = [&vy](int i, int j) { return vy(i, j); };
    const auto wave_dir_vec = std::make_pair(wave_dir_x, wave_dir_y);
    vector_properties.emplace_back(name,
        std::vector<vector_accessor_2d_type>(1, wave_dir_vec));
}

int gpm_vtk_output::write_file(const std::string& file_name) {
    FILE* outfile = fopen(file_name.c_str(), "w");

    int_extent_1d row_ext = extent.row_extent();
    int_extent_1d col_ext = extent.col_extent();
    fprintf(outfile, "# vtk DataFile Version 3.0\n");
    fprintf(outfile, "VTK File Generated by GPM\n");
    fprintf(outfile, "ASCII\n");
    fprintf(outfile, "DATASET STRUCTURED_GRID\n");

    const auto numrows = static_cast<unsigned int> (row_ext.upper());
    const auto numcols = static_cast<unsigned int> (col_ext.upper());
    const auto num_surfaces = static_cast<int>(geometries.second.size());
    const auto totnums = num_surfaces * numrows * numcols;
    fprintf(outfile, "DIMENSIONS %u %u %u \n", numcols, numrows, num_surfaces);
    float xmin = 0;
    float ymin = 0;
    fprintf(outfile, "POINTS %d float\n", totnums);
    const std::vector<accessor_2d_float_type>& geoms(geometries.second);
    for (auto layes = 0; layes < geoms.size(); ++layes) {
        for (auto i = row_ext.lower(); i < row_ext.upper(); i++) {
            for (auto j = col_ext.lower(); j < col_ext.upper(); j++) {
                float x, y;
                convert_to_world(static_cast<int> (i), static_cast<int> (j), &x, &y);
                fprintf(outfile, "%f %f %f \n", x, y, geoms[layes](static_cast<unsigned int> (i), static_cast<unsigned int> (j)));
            }
        }
    }
    fprintf(outfile, "POINT_DATA %d\n", totnums);
    // Now we push the data
    for (int propi = 0; propi < float_properties.size(); ++propi) {
        const name_accessor_float_type& prop_pair(float_properties[propi]);
        fprintf(outfile, "SCALARS %s float \n", prop_pair.first.c_str());
        fprintf(outfile, "LOOKUP_TABLE default\n");
        const std::vector<accessor_2d_float_type>& prop(prop_pair.second);
        for (auto layes = 0; layes < prop.size(); ++layes) {
            for (unsigned int i = 0; i < numrows; ++i) {
                for (unsigned int j = 0; j < numcols; ++j) {
                    float tmp_float = prop[layes](i, j);
                    fprintf(outfile, "%f \n", tmp_float);
                }
            }
        }
    }
    for (int propi = 0; propi < int_properties.size(); ++propi) {
        const name_accessor_int_type& prop_pair(int_properties[propi]);
        fprintf(outfile, "SCALARS %s int \n", prop_pair.first.c_str());
        fprintf(outfile, "LOOKUP_TABLE default\n");
        const std::vector<accessor_2d_int_type>& prop(prop_pair.second);
        for (auto layes = 0; layes < prop.size(); ++layes) {
            for (unsigned int i = 0; i < numrows; ++i) {
                for (unsigned int j = 0; j < numcols; ++j) {
                    int tmp_int = prop[layes](i, j);
                    fprintf(outfile, "%d \n", tmp_int);
                }
            }
        }
    }

    for (int propi = 0; propi < vector_properties.size(); ++propi) {
        const name_vector_accessor_type& prop_pair(vector_properties[propi]);
        fprintf(outfile, "VECTORS %s float \n", prop_pair.first.c_str());
        const std::vector<vector_accessor_2d_type>& prop_vec(prop_pair.second);
        for (auto layes = 0; layes < prop_vec.size(); ++layes) {
            for (unsigned int i = 0; i < numrows; ++i) {
                for (unsigned int j = 0; j < numcols; ++j) {
                    fprintf(outfile, "%f %f %f\n", prop_vec[layes].first(i, j), prop_vec[layes].second(i, j), 0.0);
                }
            }
        }
    }
    fprintf(outfile, "\n");
    fclose(outfile);

    return 0;
}

int gpm_vtk_output::write_file_to_unstructured(const std::string& file_name) {
	FILE* outfile = fopen(file_name.c_str(), "w");

	int_extent_1d row_ext = extent.row_extent();
	int_extent_1d col_ext = extent.col_extent();
	fprintf(outfile, "# vtk DataFile Version 3.0\n");
	fprintf(outfile, "VTK File Generated by GPM\n");
	fprintf(outfile, "ASCII\n");
	fprintf(outfile, "DATASET UNSTRUCTURED_GRID\n");

	const auto numrows = row_ext.upper();
    const auto numcols = col_ext.upper();
    const auto num_surfaces = static_cast<int>(geometries.second.size());
    const auto totnums = num_surfaces * numrows * numcols;
	//fprintf(outfile, "DIMENSIONS %d %d %d \n", numcols, numrows, num_surfaces);
	//float xmin = 0;
	//float ymin = 0;
	fprintf(outfile, "POINTS %u float\n", static_cast<unsigned int> (totnums));
	const std::vector<accessor_2d_float_type>& geoms(geometries.second);
	for (int layes = 0; layes < geoms.size(); ++layes) {
		for (auto i = row_ext.lower(); i < row_ext.upper(); i++) {
			for (auto j = col_ext.lower(); j < col_ext.upper(); j++) {
				float x, y;
                convert_to_world(static_cast<int> (i), static_cast<int> (j), &x, &y);
                fprintf(outfile, "%f %f %f \n", x, y, geoms[layes](static_cast<unsigned int> (i), static_cast<unsigned int> (j)));
            }
		}
	}
    auto cell_num = (numrows-1)*(numcols-1);
	fprintf(outfile, "CELLS %u %u\n", static_cast<unsigned int> (cell_num), static_cast<unsigned int> (cell_num*5));
	for (int layes = 0; layes < geoms.size(); ++layes) {
		for (auto i = row_ext.lower(); i < row_ext.upper()-1; i++) {
			for (auto j = col_ext.lower(); j < col_ext.upper()-1; j++) {
				fprintf(outfile, "%u %u %u %u %u \n", 4, static_cast<unsigned int> (j), static_cast<unsigned int> (j+1), 
                                                         static_cast<unsigned int> (j+1+(i+1)* col_ext.upper()), static_cast<unsigned int> (j + (i+1) * col_ext.upper()));
			}
		}
	}
	fprintf(outfile, "CELL_TYPES %u\n", static_cast<unsigned int> (cell_num));
	for (int layes = 0; layes < geoms.size(); ++layes) {
		for (auto i = row_ext.lower(); i < row_ext.upper() - 1; i++) {
			for (auto j = col_ext.lower(); j < col_ext.upper() - 1; j++) {
				fprintf(outfile, "9\n");
			}
		}
	}

	fprintf(outfile, "\n");
	fclose(outfile);

	return 0;
}

int gpm_vtk_output::write_file_to_new_unstructured(const std::string& file_name) {
	FILE* outfile = fopen(file_name.c_str(), "w");

	int_extent_1d row_ext = extent.row_extent();
	int_extent_1d col_ext = extent.col_extent();
    const auto numrows = row_ext.upper();
    const auto numcols = col_ext.upper();
    const auto num_surfaces = static_cast<int>(geometries.second.size());
    const auto totnums = num_surfaces * numrows * numcols;
    
	fprintf(outfile, "<VTKFile type=\"UnstructuredGrid\">\n");
	fprintf(outfile, "<UnstructuredGrid>\n");
	fprintf(outfile, "<Piece NumberOfPoints=\"%u\" NumberOfCells=\"%u\">\n", static_cast<unsigned int>(numrows * numcols), static_cast<unsigned int>((numrows-1) * (numcols-1)));
	fprintf(outfile, "<Points>\n");
	fprintf(outfile, "<DataArray type = \"Float64\" Name = \"Points\" NumberOfComponents = \"3\" format = \"ascii\">\n");
	//fprintf(outfile, "DIMENSIONS %d %d %d \n", numcols, numrows, num_surfaces);
	//float xmin = 0;
	//float ymin = 0;
	//fprintf(outfile, "POINTS %d float\n", totnums);
	const std::vector<accessor_2d_float_type>& geoms(geometries.second);
	for (int layes = 0; layes < geoms.size(); ++layes) {
		for (auto i = row_ext.lower(); i < row_ext.upper(); i++) {
			for (auto j = col_ext.lower(); j < col_ext.upper(); j++) {
				float x, y;
                convert_to_world(static_cast<int> (i), static_cast<int> (j), &x, &y);
                fprintf(outfile, "%f %f %f \n", x, y, geoms[layes](static_cast<unsigned int> (i), static_cast<unsigned int> (j)));
            }
		}
	}
	fprintf(outfile, "</DataArray>\n");
	fprintf(outfile, "</Points>\n");
	fprintf(outfile, "<Cells>\n");
	fprintf(outfile, "<DataArray type = \"Int32\" Name = \"connectivity\" format = \"ascii\">\n");

	auto cell_num = (numrows - 1)*(numcols - 1);
	for (int layes = 0; layes < geoms.size(); ++layes) {
		for (auto i = row_ext.lower(); i < row_ext.upper() - 1; i++) {
			auto row_start_index= (i)* col_ext.upper();
			auto rowp1_start_index = (i + 1)* col_ext.upper();
			for (auto j = col_ext.lower(); j < col_ext.upper() - 1; j++) {
				fprintf(outfile, "%u %u %u %u \n", static_cast<int> (row_start_index+j), static_cast<int> (row_start_index+(j + 1)), 
                                                   static_cast<int> (j + 1 + rowp1_start_index), static_cast<int> (j + rowp1_start_index));
			}
		}
	}
    fprintf(outfile, "</DataArray>\n");
    fprintf(outfile, "<DataArray type = \"Int32\" Name = \"offsets\" format = \"ascii\">\n");
    for (int i = 0, j=0; i < cell_num; ++i, j+=4) {
        fprintf(outfile, "%d\n", j);
    }
	fprintf(outfile, "</DataArray>\n");
	fprintf(outfile, "<DataArray type = \"Int32\" Name = \"types\" format = \"ascii\">\n");
	for (int i = 0; i < cell_num; ++i) {
		fprintf(outfile, "9\n");
	}
	fprintf(outfile, "</DataArray>\n");
	fprintf(outfile, "</Cells>\n");
	fprintf(outfile, "</Piece>\n");
	fprintf(outfile, "</UnstructuredGrid>\n");
	fprintf(outfile, "</VTKFile>\n");

	fclose(outfile);

	return 0;
}


}}}
