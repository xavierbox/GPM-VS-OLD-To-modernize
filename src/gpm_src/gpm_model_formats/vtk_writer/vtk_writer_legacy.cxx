// -- Schlumberger Private --

#include "vtk_writer_legacy.h"
#include "mapstc.h"

namespace Slb { namespace Exploration { namespace Gpm {
vtk_writer_legacy::vtk_writer_legacy(): 
    m_filin(nullptr), 
    m_parm(nullptr) 
{
}

void vtk_writer_legacy::write(const gpm_model_definition& model) {

    writevtk(model);
}

void vtk_writer_legacy::set_write_info(const std::string& fil_name, grid_parameter_type* param, const std::vector<TypeDescr>& type_info,
                                const parameter_num_type& inumr, const arrray_dim_size_type& idimr) {
    m_fil_name = fil_name;
    m_parm = param;
    m_type_info = type_info;
    m_inumr = inumr;
    m_idimr = idimr;
}

int vtk_writer_legacy::writevtk(const gpm_model_definition& model) {

    grid_parameter_type& p(*m_parm);
    int numtims = p.numtims();
    gpm_model_definition::index_pt tmp_ij;
    gpm_model_definition::world_pt tmp_xy;
    for (int times = 0; times < numtims; ++ times) {
        auto vtk_string = m_fil_name + std::to_string(times) + ".vtk";
        m_filin = fopen(vtk_string.c_str(), "w");
        if (m_filin == nullptr) {
            printf("writacf: invalid output file\n");
            return -1;
        }

        // Lets write the headers
        fprintf(m_filin, "# vtk DataFile Version 3.0\n");
        fprintf(m_filin, "VTK File Generated by GPM\n");
        fprintf(m_filin, "ASCII\n");
        fprintf(m_filin, "DATASET STRUCTURED_GRID\n");
        const auto numtops = p.numtops(); // This also contains the sealevel so we can add that as a simple grid

        const auto numrows = p.numrows();
        const auto numcols = p.numcols();
        std::vector<function_2d> surface_stack;
        for (int i = 0; i < numtops; ++i) {
            auto tmp = p.indprop(0, times, i);
            if (tmp.is_initialized()) {
                surface_stack.push_back(tmp);
            }
            else {
                // Need to pump out all timesteps for Paraview to work
                surface_stack.push_back(surface_stack.back());
            }
        }

        const auto num_surfaces = static_cast<int>(surface_stack.size());
        const auto totnums = num_surfaces * numrows * numcols;
        fprintf(m_filin, "DIMENSIONS %ld %ld %d \n", numcols, numrows, num_surfaces);
        // How do we get the surface indexes
        std::vector<int> indexes(3);
        std::vector<int> zgrid_ids;
        indexes[0] = 0;
        indexes[1] = numtims - 1;

        fprintf(m_filin, "POINTS %ld float\n", totnums);

        for (std::size_t i = 0; i < surface_stack.size(); ++i) {
            const auto tmp = surface_stack[i];
            for (int j = 0; j < numrows; ++j) {
                tmp_ij.i=static_cast<float>(j);
                for (auto k = 0; k < numcols; ++k) {
                    tmp_ij.j=static_cast<float>(k);
                    tmp_xy = model.convert_from_index_to_world(tmp_ij);
                    fprintf(m_filin, "%f %f %f \n", tmp_xy.x, tmp_xy.y, tmp(j, k));
                }
            }
        }
        fprintf(m_filin, "POINT_DATA %ld\n", totnums);
        for (std::size_t attr = 1; attr < p.propnam.size(); ++attr) {
            fprintf(m_filin, "SCALARS %s float \n", p.propnam[attr].c_str());
            fprintf(m_filin, "LOOKUP_TABLE default\n");
            surface_stack.clear();
            for (auto i = 0; i < num_surfaces; ++i) {
                auto tmp = p.indprop(static_cast<int>(attr), times, i);
                if (tmp.is_initialized()) {
                    surface_stack.push_back(tmp);
                }
                else {
                    surface_stack.empty() ? surface_stack.push_back(tmp) : surface_stack.push_back(surface_stack.back());
                }
            }
            for (std::size_t i = 0; i < surface_stack.size(); ++i) {
                auto tmp = surface_stack[i];
                for (auto j = 0; j < numrows; ++j) {
                    for (auto k = 0; k < numcols; ++k) {
                        const auto tmp_float = tmp.is_initialized() ? tmp(j, k) : 0;
                        fprintf(m_filin, "%f \n", tmp_float);
                    }
                }
            }
        }

        fprintf(m_filin, "\n");
        fclose(m_filin);
    }

    return 0;
}

}}}
